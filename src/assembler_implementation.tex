\chapter{Assembler Implementation}
In order to test our implementation and execute sample programs, we need access to an assembler that supports our newly added instructions. We opted to extend CHERI's fork of the LLVM project that already has support for compiling and assembling code to CHERI supported architectures, including CHERI-RISC-V.

\section{LLVM Modifications}
The code snippet below shows all of the required modifications to LLVM to compile assembly programs that use the instructions added with borrowed capabilities. This snippet belongs in the \textit{RISCVInstrInfoXCheri.td} file, found in the \textit{llvm/lib/Target/RISCV/} directory, starting from the LLVM repository root.

%TODO formatting
\begin{verbatim}
let Predicates = [HasCheri] in {
def CGetLinear     : Cheri_r<0x14, "cgetlinear">;
let mayTrap = 1 in {
def CMakeLinear    : Cheri_r<0x13, "cmakelinear", GPCR>;
def CCreateToken   : Cheri_r<0x15, "ccreatetoken", GPCR>;
def CKillToken     : Cheri_r<0x16, "ckilltoken", GPCR>;
def CSplitLT       : Cheri_r<0x17, "csplitlt", GPCR>;
def CSplitCap      : Cheri_rr<0x1a, "csplitcap">;
def CMergeCap      : Cheri_rr<0x1b, "cmergecap", GPCR, GPCR>;
def CUnlockToken   : Cheri_rr<0x15, "cunlocktoken", GPCR, GPCR>;
def CMergeLT       : Cheri_rr<0x16, "cmergelt", GPCR, GPCR>;
def CBorrowImmut   : Cheri_rr<0x17, "cborrowimmut", GPCR, GPCR>;
def CBorrowMut     : Cheri_rr<0x18, "cborrowmut", GPCR, GPCR>;
def CRetrieveIndex : Cheri_rr<0x19, "cretrieveindex", GPCR, GPCR>;
}
}

let Predicates = [HasCheri, IsRV64] in
def LL_CAP_128 : CheriLoad_r<0b00111, "ll.cap", GPCR, GPCRMemAtomic>;

let Predicates = [HasCheri, IsRV64] in
def SL_CAP_128 : CheriStore_r<0b01101, "sl.cap", GPCR, GPCRMemAtomic>;
\end{verbatim}

The code snippet defines all of the new instructions and specifies how they need to be encoded. Most of the instructions make use of the \textit{Cheri\_r} or \textit{Cheri\_rr} templates, discussed in section \ref{} %TODO reference background
The first argument to these templates, the funct5 or funct7 arguments, express how the mnemonic stated in the second argument should be encoded to bits. The funct5 or funct7 arguments correspond to the encoding as shown in section \ref{sec:sailencoding}. The remainder of the arguments are optional and used to override the defaults in the template. Passing \textit{GPCR} to the template expresses that the corresponding register should be interpreted as a capability register.

The \textit{ll.cap} and \textit{sl.cap} instructions that stand for the linear load and store instructions use a different template, corresponding to their purpose, but follow the same principles as above. The first argument expresses the encoding, the second argument is the mnemonic to be used and the third and fourth arguments define the interpretation of operands.

The use of hexadecimal notation for the first set of instructions and binary notation for the load and store instructions follows the style of the already existing code in the file.

\section{Compiling Assembly}
\begin{verbatim}
clang -nostdlib --target=riscv64-unknown-elf-64 -march=rv64gcxcheri
-mno-relax -Ttext 0x80000000 -o out.elf asm.s
\end{verbatim}
This command is the command used to assemble an assembly file called \textit{asm.s} to an executable ELF binary called \textit{out.elf}. The command uses the clang executable that was produced by compiling LLVM with the modifications described above. The flags tell clang to produce a CHERI-RISC-V ELF file without linking against the standard library with linker relaxation enabled. The \textit{-Ttext 0x80000000} tells the emulator to load the generated code in memory starting at address \textit{0x80000000}. This necessary because the emulator does not consider smaller addresses as ram and will refuse to execute the program.

\section{Considerations}
LLVM instructions are usually connected to certain directives with the purpose of improving the quality of the code generated by the compiler. One such directive can be seen in the snippet with the \textit{mayTrap} directive. Since we do not need a compiler for the purposes of this thesis, we do not concern ourselves with the efficiency or even correctness of the usage of these directives. These directives are ignored when using the assembler, like we do in this thesis.
