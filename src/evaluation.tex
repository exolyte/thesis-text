\chapter{Evaluation}
\label{chap:evaluation}
To evaluate our design of borrowed capabilities we will construct some assembly programs and argue about how they are similar to certain Rust programs that each demonstrate a particular feature of Rust's semantics.
This allows us to evaluate how well an ISA with borrowed capabilities can be used as a target language for a Rust compiler.
The given assembly programs were run on the ocaml emulator that was generated by the Sail implementation of borrowed capabilities.

Because we only have an emulator and no actual hardware implementation, it is hard to evaluate the performance of our design.
We will not evaluate the design on performance, but we will discuss it briefly in chapter \ref{chap:discussion}.

In this chapter we will also make a qualitative analysis about the costs of implementing borrowed capabilities in CHERI and in hardware and discuss some limitations around borrowed capabilities.

\section{Rust Comparison}
\label{sec:rustexampleseval}
In this section we introduce assembly programs that mirror the functionality of the Rust examples that we discussed in section \ref{sec:rustbackground}.
These assembly programs can also be found in the \textit{examples} directory of the Sail model repository at \url{https://github.com/exolyte/sail-cheri-riscv}.

\subsection{Common Assembly Explanation}
In this section we explain the assembly code that is required to set up the program and is common to all of the examples we will show in this chapter.
To save space and to focus on the essential part of the assembly, we will not repeat the code that is given here in figure \ref{fig:commonasm}.
Parts of this code were inspired by the code for the official RISC-V test examples \cite{riscvtest}.

\begin{figure}[h]
\begin{lstlisting}[style=custASM, numbers = left ,xleftmargin=1.5em]
        .global _start
_start:
        la      t0, _trap_vector
        csrw	mtvec, t0

        la      t0, _user
        csrw    mepc, t0
        mret

.align 4
_trap_vector:
        li      gp, 3
        j       _exit

_exit:
        auipc   t5, 0x1
        sw      gp, tohost, t5
        j       _exit

_user:
        CSpecialRW  c2, ddc, c0
        li          x1, 0b111101
        CAndPerm    c2, c2, x1
        li          x1, 0x82000000
        CIncOffset  c2, c2, x1
        li          x1, 8
        CSetBounds  c20, c2, x1
        li          x1, 4
        CSetBounds  c2, c2, x1
        CMakeLinear c2, c2
        CMakeLinear c20, c20
        
        ...
        
        li  gp,1
        j   _exit

.align 6; .global tohost; tohost: .dword 0;
\end{lstlisting}
\caption{The common assembly code.}
\label{fig:commonasm}
\end{figure}

The assembly snippet starts off by defining the \textit{\_start} label which is read by the emulator and used to determine where the emulator should start executing code.
The code at the \textit{\_start} label loads the address of the \textit{\_trap\_vector} label in the \textit{t0} register and then sets that address as the address to trap to when an instruction encounters an exception with the \textit{csrw} instruction.
The following two lines do something similar but set the return address that is returned to when executing the \textit{mret} instruction instead.
Then the \textit{mret} instruction causes the emulator to enter user mode and jump to the \textit{\_user} label.
The place with \ldots under the \textit{\_user} label is where the code that we give throughout this chapter will be placed when executing the examples.
There is also some common set-up code under the \textit{\_user} label that will be explained later.

The code at the \textit{\_trap\_vector} label loads the value 3 in a register that will be used to pass the return code of the program to the emulator and then jumps to the \textit{\_exit} label.
The code at the \textit{\_exit} label writes the value in \textit{gp} to the \textit{tohost} address which is considered communication with the emulator.
The emulator considers any value with the least significant bit set to 1 as a message to stop the emulation with a return code defined by the number in the other bits of the value.
A return code of zero means that the program exited successfully while any other value signifies an error code that corresponds to a failure in the program.
In the section of code at \textit{\_trap\_vector} we set the value to 3 which corresponds to a failure with error code 1.
This happens when some instruction in our program raises an exception.
At the end of the code under the \textit{\_user} label we set the value of \textit{gp} to 1 to signify successful completion of the code.

The rest of the code under the \textit{\_user} label consists of set-up code that we need for our example programs.
The \textit{CSpecialRW} instruction gets a capability with the maximum amount of permissions from the DDC register and stores it in the $c2$ register.
The binary value \textit{111101} is then loaded in $x1$, representing the presence of the \textit{Global} and the load and store CHERI permissions, but none of the others.
These permissions are applied to the capability in $c2$ through the \textit{CAndPerm} instruction.
We then set the offset of the capability to point to \textit{0x82000000} which is an arbitrary address in system memory.
The first \textit{CSetBounds} instruction duplicates the capability to $c20$, sets the base to \textit{0x82000000} and sets the length to 8 which is the length of two 32 bit words.
This capability in $c20$ will be used in one of the later program examples.
The second \textit{CSetBounds} instruction does something similar to the capability in $c2$, but sets the length to 4 instead.
The last two lines of the code under the \textit{\_user} label make both of these capabilities linear so that they behave like Rust owner variables.

The final line of the assembly defines the \textit{tohost} symbol and address so that the emulator knows which address it should be listening to.

\subsection{Borrowing}
We start off with the example that we gave to illustrate borrowing in listing \ref{code:borrowexample}.
The assembly equivalent of this Rust program is shown in figure \ref{fig:asmborrowexample}.
The first two lines load an integer to integer register $x1$ and store that integer in the memory pointed to by the capability in capability register $c2$.
This is somewhat similar to creating a new variable, $x$, and assigning it a value.

\begin{figure}[h]
\begin{lstlisting}[style=custASM, numbers = left ,xleftmargin=1.5em]
li             x1, 5
sw.cap         x1, 0(c2)     #let mut x = 5;

CCreateToken   c31, c0       #{
CBorrowMut     c3,  c2, c31  #m = &mut x;
lw.cap         x1,  0(c2)
addi           x1,  x1, 1
sw.cap         x1,  0(c2)    #*m += 1;

CKillToken     c31, c31      #}
CRetrieveIndex c3,  c3, c31
CMove          c2,  c3

CCreateToken   c31, c0       #{
CBorrowImmut   c5,  c2, c31  #let x_shell = &x;
CMove          c3,  c2       #let x_temp = x_shell;
CMove          c30, c31
CCreateToken   c31, c30      #{
CBorrowImmut   c0,  c3, c31  #let s1 = &x_temp;
CMove          c4,  c2       #let x_temp = x_shell;
CBorrowImmut   c0,  c4, c31  #let s2 = &x_temp;

lw.cap         x1,  0(c3)    #println!("{}", s1);
lw.cap         x1,  0(c4)    #println!("{}", s2);
CMove          c29, c31
CMove          c31, c30
lw.cap         x1,  0(c2)    #println!("{}", x_shell);

CKillToken     c29, c29      #}
CUnlockToken   c31, c31, c29
CKillToken     c31, c31      #}
CRetrieveIndex c5,  c5,  c31
\end{lstlisting}
\caption{An assembly program illustrating borrowing.}
\label{fig:asmborrowexample}
\end{figure}

The next five lines start by creating a lifetime token, which is roughly similar to opening a new scope.
In Rust, a lifetime is an abstract thing that is attached to a pointer while in borrowed capabilities a lifetime is represented as its own separate token as seen in this assembly.
The lifetime token is then used to mutably borrow $x$ with the borrowed capability $m$ being placed in register $c2$ and the resulting index token being placed in $c3$.
The borrow operation also locks the capability corresponding to $x$ away in the borrow table which ensures that it cannot be used to read or write from, just as Rust guarantees.
The borrowed capability is then used to load the value, increment it and store it again.
These load and store operations succeed because the lifetime token is in the lifetime token register of $c31$.

In the following block the lifetime token is killed and then used with the index token in $c3$ to retrieve the original capability corresponding to $x$.
The capability is then moved back to $c2$ which results in the same state as the start of the program, with the exception of the incremented integer in $x1$ and memory.

In the following lines, the assembly program diverges slightly from the original Rust program for reasons we discussed in section \ref{sec:designdisadvantages}.
This is because borrowing $x$ results in the capability being locked away in the borrow table which makes it impossible to dereference while in the Rust example, the $x$ variable is read from within the lifetime of the borrows.
The solution is to create an immutable shell borrow of $x$ under its own lifetime that can then be copied and reborrowed which is done in lines 14-16.
While this is semantically different from the original Rust program, it matches the behavior for immutable borrows where the owner can be used to read from, but not write to the resource.
In line 18 a sublifetime is created which is then used to reborrow a copy of the $x\_shell$ variable in lines 19-21.
We will expand more on reborrows in the next section.
Because we don't care about retrieving the copy of the $x\_shell$ variable, we set the output for the index token in the borrow operations to $c0$ which results in no capability being locked away in the borrow table and no index token being created.

The capabilities corresponding to $x\_shell$, $s1$ and $s2$ can then be used to print the value they point to, which we represent in a simplified manner by loading the value they point to.
Because $x\_shell$ was borrowed under a different lifetime than $s1$ and $s2$, the lifetime tokens must be moved around to allow for dereferencing the capability in $c2$.
The last four lines kill the sublifetime, use that dead lifetime token to remove the child from the parent lifetime which then enables the parent lifetime to be killed.
The dead parent lifetime token can then be used with the index token in $c5$ to retrieve the original mutable capability corresponding to the $x$ variable.

\subsection{Reborrowing}
While we did have an example of reborrowing in the previous section, reborrowing also exists explicitly in Rust as seen in section \ref{sec:backgroundreborrow}.
In this section we give an assembly program in figure \ref{fig:asmreborrowexample} that corresponds to the Rust program shown in listing \ref{code:reborrow_semantics}.

\begin{figure}[h]
\begin{lstlisting}[style=custASM, numbers = left ,xleftmargin=1.5em]
li             x1,  5
sw.cap         x1,  0(c2)   #let mut x = 5;
CCreateToken   c30, c0      #{
CBorrowMut     c3,  c2, c30 #m = &mut x;

CCreateToken   c31, c30     #{
CBorrowImmut   c4,  c2, c31 #let s = &(*m);
lw.cap         x1,  0(c2)   #println!("{}", s);

CKillToken     c31, c31     #}
CUnlockToken   c30, c30, c31
CRetrieveIndex c4,  c4, c31

CMove          c31, c30
lw.cap         x1,  0(c4)
addi           x1,  x1, 1
sw.cap         x1,  0(c4)   #*m += 1;

CKillToken     c31, c31     #}
CRetrieveIndex c3,  c3, c31
\end{lstlisting}
\caption{An assembly program illustrating reborrowing.}
\label{fig:asmreborrowexample}
\end{figure}

The first four lines of the program are similar to the previous assembly program.
On line 6 we create a new lifetime token as the child of the token in $c30$ which can be used to reborrow borrowed capabilities with that lifetime.
This is what we do on line 7, where the mutably borrowed capability gets locked away in the borrow table, the new immutably borrowed capability takes its place and the index token gets placed in $c4$.
Locking the mutable borrow away means that an error such as the one in listing \ref{code:reborrow_semantics_wrong} where the mutable reference is used while the immutable reference exists, cannot occur.
The integer value is then loaded through the immutably borrowed capability.

The lifetime token for the immutable borrow is then killed and used to unlock the parent lifetime token.
This guarantees that the immutable borrow cannot be used anymore and it is safe to retrieve the mutable borrow.
This is done in line 12 through the index token in $c4$.

The rest of the program is once again similar to the program in the previous section.

\subsection{Borrowing Struct Fields}
Figure \ref{fig:asmstructexample} shows the assembly that corresponds to the Rust code in listing \ref{code:struct_semantics} where individual fields of a struct get borrowed.

\begin{figure}[h]
\begin{lstlisting}[style=custASM, numbers = left ,xleftmargin=1.5em]
CMove          c2,  c20
li             x1,  0
sw.cap         x1,  0(c2)
li             x9,  4
CIncOffset     c2,  c2, x9
sw.cap         x1,  0(c2)   #let mut s = S{a:0,b:0};
CCreateToken   c31, c0      #{

CBorrowMut     c4, c2, c31
CSplitCap      c3, c2, x9   #a = &mut s.a;
                            #b = &mut s.b;

lw.cap         x1, 0(c3)
addi           x1, x1, 1
sw.cap         x1, 0(c3)    #*a += 1;

lw.cap         x1, 0(c2)
addi           x1, x1, 2
sw.cap         x1, 0(c2)    #*b += 2;

CMergeCap      c3,  c3, c2
CKillToken     c31, c31     #}
CRetrieveIndex c4,  c4, c31
\end{lstlisting}
\caption{An assembly program illustrating borrowing struct fields.}
\label{fig:asmstructexample}
\end{figure}

In this example we use the capability in $c20$ that points to two 32 bit words.
For simplicity we start by moving it to $c2$.
We then load 0 in the lower word corresponding to the struct's $a$ field, increase the offset on the capability to point to the upper word and load 0 in the upper word corresponding to the $b$ field.
To create borrows of the individual fields we first create a borrow of the full capability in $c2$ which we then split between the lower and upper word with the \textit{CSplitCap} instruction on line 10.
After this instruction the capability pointing to only the lower word, corresponding to $a$, is present in the $c3$ register while the capability pointing to only the upper word is in the $c2$ register.
We then increment the values in the way shown in the previous examples.
On line 21 the two fields are of the struct are joined together again with the \textit{CMergeCap} instruction.
This is not necessary, but we include it to show the working of the instruction.
The end of the program is the same as in the previous examples.

\subsection{Using Lifetime Fractions}
In this section we give an assembly program that corresponds to a simplified version of the threading example that we gave in listing \ref{code:thread}.
The example in listing \ref{code:thread} was slightly complicated to work around limitations around threading in the Rust standard library, but because borrowed capabilities do not have those limitations we can give a simpler example here in figure \ref{fig:asmthreadexample}.
Because real threading involves a scheduler and pre-empting, we will describe the creation of a thread instead of giving code as to keep the assembly simple.

\begin{figure}[h]
\begin{lstlisting}[style=custASM, numbers = left ,xleftmargin=1.5em]
li             x1, 5
sw.cap         x1, 0(c2)    #let mut x = 5;

CCreateToken   c31, c0      #{
CBorrowImmut   c4,  c2, c31 #m = &x;
CMove          c3,  c2
CSplitLT       c30, c31

#Move registers c2 and c30   #let handle1 =
#to new thread.              #thread::spawn(...);
#Move registers c3 and c31   #let handle2 =
#to new thread.              #thread::spawn(...);
#...
#Retrieve lifetime fraction  #handle1.join();
#from thread and place it
#in c30.
#Retrieve lifetime fraction  #handle2.join();
#from thread and place it
#in c31.

CMergeLT       c30, c30, c31
CKillToken     c30, c30      #}
CRetrieveIndex c4,  c4,  c30
\end{lstlisting}
\caption{An assembly program illustrating the use of lifetime fractions.}
\label{fig:asmthreadexample}
\end{figure}

The first five lines are once again similar to previous examples.
On line 6 we make a copy of the immutable borrow so that we have two copies of the borrow and we can give one to each thread.
On line 7 we split the lifetime token into two fractions, one for each thread.
The next few lines describe the creation and ending of two new threads.
After the threads are finished, we merge the two lifetime fractions to obtain the full lifetime token which allows us to kill the lifetime token and retrieve the original capability.

\subsection{Nested references}
\label{sec:nestedrefeval}
In section \ref{sec:rust_nested} we explained Rust's rules around loading references through a borrow.
In listing \ref{code:nested_borrow} we demonstrated that a mutable reference has to be borrowed when loaded through a borrow.
This is not supported in our design for borrowed capabilities because the borrow operations work only on registers, not on memory.
A solution for this would involve a new instruction that loads the mutable capability, stores it in the borrow table, places a borrowed capability in the output register with a lifetime id that matches a provided lifetime token and writes an index token to memory.
This instruction that is a fusion of a load and borrow operation would be very complex and it might not be realistic to implement this in microarchitecture.
Additionally, any reference that is loaded in this way is actually a reborrow of the nested reference and thus needs to have a shorter lifetime than the nested reference itself, regardless of whether it is a mutable or immutable reference.
In our design this means that the lifetime token provided to the load-borrow instruction needs to be a child of the lifetime of the nested reference, adding further complexity to the instruction.
Another issue is that such an instruction would give issues with loading references that already use their \textit{otype} field for another purpose because then the \textit{otype} would not be available for a lifetime id.

Another issue is that in Rust immutable references can not be used to load mutable references as explained in \ref{code:nested_immutmut}.
Instead, the loaded references are made immutable which in turn renders them unable to load mutable references.
Simply unsetting the write permissions on a capability that is loaded through an immutable borrowed capability is not sufficient as this loaded capability would be able load mutable capabilities itself, losing the recursive property.
A possible solution would be to use the experimental CHERI \textit{Permit\_Recursive\_Mutable\_Load} permission \cite{UCAM-CL-TR-951} that removes store permissions and this permission itself on any capability that is loaded through a capability that does not have this permission set.

\section{Cost to CHERI}
\label{sec:chericost}
CHERI has to be modified in a few ways to support borrowed capabilities.
The most significant change is the split of the otype space between lifetime id's and other purposes.
This almost halves the amount of available otype values for code-data pairs.
This does not seem like a very big problem however since there are still $2^{17} - 16 = 131056$ available values which should be more than enough for code-data pairs.
Another change to the \textit{otype} field is the addition of identifiers for lifetime and index tokens to the 16 reserved otype values.
Because CHERI currently uses only two of these 16 values and this space can easily be extended, this does not seem expensive.

Apart from the \textit{linear} bit for linear capabilities, our implementation does not use extra bits on the capability layout.
This is significant because the amount of leftover bits on the capability layout is very limited.
The implementation of linear capabilities added 6 new instructions and the implementation of borrowed capabilities added 8 new instructions.
Five of these instructions have two operands and use the instruction encoding where the \textit{func7} field is fixed and the interpretation of the instruction is determined by the \textit{func5} field.
Together with the already existing CHERI instructions, there are now 24 instructions that use this encoding while the space is limited to 32 instructions, but the space can presumably be expanded by using additional values for the \textit{func7} field.
The next seven instructions have three operands and thus use a variable \textit{func7} field to be identified, bringing the total amount of instructions that use this encoding up to 27 out of a possible 128.
The last two instructions are the linear load and store instructions.
Loads and stores have a fixed \textit{func7} and use the \textit{func5} field to identify the type of load or store, resulting in a possible 32 load instructions and 32 store instructions.
The addition of \textit{LinearLoadCapCap} brings the amount load instructions up to 29 and the addition of \textit{LinearStoreCapCap} brings the amount of store instructions up to 21.

\section{Hardware Cost}
\label{sec:hardwareeval}
In this section we try to estimate the cost of implementing borrowed capabilities in hardware.
Because we have not made any actual hardware, these costs are hard to determine so we will give a qualitative argument for why some instructions are expensive or difficult to implement in hardware.

Throughout this thesis we occasionally mentioned the need for instructions to write to multiple registers and the microarchitectural difficulties connected to this.
In table \ref{table:multiplewrites} we present the instructions that require writing to multiple registers.
We make a distinction between instructions that just need to invalidate the tag on capabilities in a specific register and instructions that need to write to the actual contents of a register as we suspect that clearing the tag on a capability in a specific register might be easier to implement in microarchitecture.

\begin{table}[h]
\centering
\begin{tabular}{| c | c |}
\hline
Clear Tag & Full Write \\
\hline
 CMergeCap & CSplitCap \\
 CMergeLT & CSplitLT \\
 CMove & CBorrowImmut \\
 CInvoke & CBorrowMut \\
 & CCreateToken \\
\hline
\end{tabular}
\caption{Instructions with multiple writes.}
\label{table:multiplewrites}
\end{table}

The \textit{LinearLoadCapCap} instruction has to both read a capability from memory and write to memory to unset the tag related to that capability.
This is unusual and might be hard to implement.
Any operation that involves the borrow table would also be hard to implement because the borrow table essentially introduces an alternative addressing mode.
In section \ref{sec:microarchbt} we briefly discuss the implementation of the borrow table itself.

The last thing to note is that with the introduction of lifetime and index tokens, the hardware that interprets the fields of a capability would have to change since these tokens have differing field layouts from normal capabilities.
However, because we avoided combining existing capability fields for these tokens, these costs may be relatively small.

\section{Limitations}
\subsection{Lifetime Id Exhaustion}
As mentioned, lifetime id's are stored in the \textit{otype} field for capabilities which is 18 bits wide.
Because this otype space is shared with other applications for the \textit{otype} field, we reserved the lower half of the space for lifetime id's.
This means that there are 17 bits available for lifetime id's with one reserved value of 0 to indicate the absence of a parent or child on lifetime tokens.
This means that these 17 available bits can be used to represent $2^{17} - 1 = 131071$ unique lifetime id's.
Since dead lifetime tokens can be freely copied, it is impossible to just reuse lifetime id's since an old dead token could be used to prove the death of a living reused lifetime.
$131071$ lifetime id's may seem like a lot, but it is probably quite restrictive.
Some software such as browsers or operating systems may run for hours or even months in the case of servers.
Assuming a program written in Rust that uses a lifetime id for every unique Rust lifetime that runs for 10 hours or 36000 seconds, the budget for lifetime id's would be less than four per second which is probably too small.
Of course consumption of lifetime id's could be drastically lowered when they are only used to protect capabilities that are given to untrusted libraries.
In this case the $131071$ unique lifetime id's might be more reasonable.

One possible solution to lifetime id exhaustion could be to change the lifetime id's of all capabilities with lifetimes in memory and registers.
This would take a sweep through memory that detects capabilities using lifetime id's and reassigns each unique old lifetime id a new lifetime id, starting with the lowest possible lifetime id.
This operation would then reset the lifetime counter to the amount of unique lifetime id's currently in use, plus one.
The obvious problems with this operation are its complexity and its performance impact, although the performance impact might be acceptable in some cases if this operation runs only once every few hours.

\section{Conclusion}
As discussed in section \ref{sec:nestedrefeval}, our design of borrowed capabilities has some issues with regards to supporting Rust's semantics around nested references.
Nevertheless, as shown in the rest of section \ref{sec:rustexampleseval}, borrowed capabilities do successfully mirror a lot of the semantics of Rust's ownership and borrowing system.
While not perfect, we think borrowed capabilities make a significant contribution in this regard.
The impact of borrowed capabilities on the CHERI architecture is fairly limited, however with the advent of RISC-V compressed instructions, the encoding space becomes more limited and the cost of adding the new instructions may rise.
Some parts of the design of borrowed capabilities might be hard to implement, such as the instructions relating to the borrow table and the borrow table itself, instructions that have multiple output registers and the interpretation of lifetime and index tokens.
Additionally, lifetime id exhaustion could be a real problem for some applications.
