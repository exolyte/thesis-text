@Book{h2g2,
  author =    {Adams, Douglas},
  title =     {The Hitchhiker's Guide to the Galaxy},
  publisher = {Del Rey (reprint)},
  year =      1995,
  note =      {ISBN-13: 978-0345391803}}

@TechReport{UCAM-CL-TR-951,
  author =	 {Watson, Robert N. M. and Neumann, Peter G. and Woodruff,
          	  Jonathan and Roe, Michael and Almatary, Hesham and
          	  Anderson, Jonathan and Baldwin, John and Barnes, Graeme and
          	  Chisnall, David and Clarke, Jessica and Davis, Brooks and
          	  Eisen, Lee and Filardo, Nathaniel Wesley and Grisenthwaite,
          	  Richard and Joannou, Alexandre and Laurie, Ben and
          	  Markettos, A. Theodore and Moore, Simon W. and Murdoch,
          	  Steven J. and Nienhuis, Kyndylan and Norton, Robert and
          	  Richardson, Alexander and Rugg, Peter and Sewell, Peter and
          	  Son, Stacey and Xia, Hongyan},
  title = 	 {{Capability Hardware Enhanced RISC Instructions: CHERI
         	   Instruction-Set Architecture (Version 8)}},
  year = 	 2020,
  month = 	 oct,
  url = 	 {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-951.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  number = 	 {UCAM-CL-TR-951}
}

@article{10.1145/3290332,
author = {Skorstengaard, Lau and Devriese, Dominique and Birkedal, Lars},
title = {StkTokens: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290332},
doi = {10.1145/3290332},
abstract = {We propose and study StkTokens: a new calling convention that provably enforces well-bracketed control flow and local state encapsulation on a capability machine. The calling convention is based on linear capabilities: a type of capabilities that are prevented from being duplicated by the hardware. In addition to designing and formalizing this new calling convention, we also contribute a new way to formalize and prove that it effectively enforces well-bracketed control flow and local state encapsulation using what we call a fully abstract overlay semantics.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {19},
numpages = {28},
keywords = {stack frame encapsulation, secure compilation, well-bracketed control flow, fully abstract overlay semantics, capability machines, linear capabilities, fully abstract compilation}
}

@article{10.1145/3341688,
author = {Van Strydonck, Thomas and Piessens, Frank and Devriese, Dominique},
title = {Linear Capabilities for Fully Abstract Compilation of Separation-Logic-Verified Code},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341688},
doi = {10.1145/3341688},
abstract = {Separation logic is a powerful program logic for the static modular verification of imperative programs. However, dynamic checking of separation logic contracts on the boundaries between verified and untrusted modules is hard, because it requires one to enforce (among other things) that outcalls from a verified to an untrusted module do not access memory resources currently owned by the verified module.  This paper proposes an approach to dynamic contract checking by relying on support for capabilities, a well-studied form of unforgeable memory pointers that enables fine-grained, efficient memory access control. More specifically, we rely on a form of capabilities called linear capabilities for which the hardware enforces that they cannot be copied.  We formalize our approach as a fully abstract compiler from a statically verified source language to an unverified target language with support for linear capabilities. The key insight behind our compiler is that memory resources described by spatial separation logic predicates can be represented at run time by linear capabilities. The compiler is separation-logic-proof-directed: it uses the separation logic proof of the source program to determine how memory accesses in the source program should be compiled to linear capability accesses in the target program.  The full abstraction property of the compiler essentially guarantees that compiled verified modules can interact with untrusted target language modules as if they were compiled from verified code as well.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {84},
numpages = {29},
keywords = {capabilities, separation logic, verification, fully abstract compilation}
}

@article{Watson2015CHERIAH,
  title={CHERI: A Hybrid Capability-System Architecture for Scalable Software Compartmentalization},
  author={R. Watson and J. Woodruff and P. Neumann and S. Moore and J. Anderson and D. Chisnall and Nirav H. Dave and B. Davis and Khilan Gudka and B. Laurie and Steven J. Murdoch and R. Norton and M. Roe and S. Son and Munraj Vadera},
  journal={2015 IEEE Symposium on Security and Privacy},
  year={2015},
  pages={20-37}
}

@misc{kan2020executable,
      title={An Executable Operational Semantics for Rust with the Formalization of Ownership and Borrowing}, 
      author={Shuanglong Kan and Zhe Chen and David Sanan and Shang-Wei Lin and Yang Liu},
      year={2020},
      eprint={1804.07608},
      howpublished = "\url{https://arxiv.org/abs/1804.07608}"},
      url={https://arxiv.org/abs/1804.07608},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@inproceedings{xia_cherivoke_2019,
  title = {{{CHERIvoke}}: {{Characterising Pointer Revocation}} Using {{CHERI Capabilities}} for {{Temporal Memory Safety}}},
  shorttitle = {{{CHERIvoke}}},
  booktitle = {{{IEEE}}/{{ACM International Symposium}} on {{Microarchitecture}}},
  author = {Xia, Hongyan and Woodruff, Jonathan and Ainsworth, Sam and Filardo, Nathaniel W. and Roe, Michael and Richardson, Alexander and Rugg, Peter and Neumann, Peter G. and Moore, Simon W. and Watson, Robert N. M. and Jones, Timothy M.},
  year = {2019},
  month = oct,
  publisher = {{ACM}},
  doi = {10.1145/3352460.3358288},
}

@inproceedings{nathaniel_wesley_filardo_cornucopia_2020,
  title = {Cornucopia: {{Temporal Safety}} for {{CHERI Heaps}}},
  booktitle = {{{IEEE Symposium}} on {{Security}} and {{Privacy}}},
  author = {Nathaniel Wesley Filardo and {Brett F. Gutstein} and {Jonathan Woodruff} and {Sam Ainsworth} and {Lucian Paul-Trifu} and {Brooks Davis} and {Hongyan Xia} and {Edward Tomasz Napierala} and {Alexander Richardson} and {John Baldwin} and {David Chisnall} and {Jessica Clarke} and {Khilan Gudka} and {Alexandre Joannou} and {A. Theodore Markettos} and {Alfredo Mazzinghi} and {Robert M. Norton} and {Michael Roe} and {Peter Sewell} and {Stacey Son} and {Timothy M. Jones} and {Simon W. Moore} and {Peter G. Neumann} and {Robert N. M. Watson}},
  year = {2020},
  month = may,
  publisher = {{IEEE}},
  timestamp = {2020-05-28T08:16:03Z}
}

@InProceedings{skorstengaard:esop18,
  author    = {Lau Skorstengaard and
               Dominique Devriese and
               Lars Birkedal},
  title     = {Reasoning About a Machine with Local Capabilities - Provably Safe
               Stack and Return Pointer Management},
  booktitle = {European Symposium on Programming},
  pages     = {475--501},
  year      = {2018},
  doi       = {10.1007/978-3-319-89884-1\_17}
}

@article{georges_efficient_2021,
  title = {Efficient and Provable Local Capability Revocation Using Uninitialized Capabilities},
  author = {Georges, A{\"i}na Linn and Gu{\'e}neau, Arma{\"e}l and Van Strydonck, Thomas and Timany, Amin and Trieu, Alix and Huyghebaert, Sander and Devriese, Dominique and Birkedal, Lars},
  year = {2021},
  month = jan,
  volume = {5},
  pages = {6:1--6:30},
  doi = {10.1145/3434287},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {capability machines,capability revocation,capability safety,CHERI,local capabilities,program logic,uninitialized capabilities,universal contracts},
  number = {POPL},
  timestamp = {2021-01-25T15:00:43Z}
}

@article{van_strydonck_linear_2019,
  title = {Linear Capabilities for Fully Abstract Compilation of Separation-Logic-Verified Code},
  author = {Van Strydonck, Thomas and Piessens, Frank and Devriese, Dominique},
  year = {2019},
  volume = {ICFP},
  journal = {Proc. ACM Program. Lang.},
  timestamp = {2019-08-05T13:26:42Z}
}

@article{skorstengaard:popl19, 
author = {Skorstengaard, Lau and Devriese, Dominique and Birkedal, Lars}, 
title = {{StkTokens}: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities}, 
year = {2019}, 
issue_date = {January 2019}, 
publisher = {Association for Computing Machinery}, 
address = {New York, NY, USA}, 
volume = {3}, 
number = {POPL}, 
doi = {10.1145/3290332}, 
journal = {Proc. ACM Program. Lang.}, 
month = jan, 
articleno = {19}, 
numpages = {28}, 
keywords = {linear capabilities, stack frame encapsulation, secure compilation, well-bracketed control flow, fully abstract compilation, fully abstract overlay semantics, capability machines} 
}

@inproceedings{van_der_veen_memory_2012,
	title = {Memory {Errors}: {The} {Past}, the {Present}, and the {Future}},
	url = {http://www.few.vu.nl/~herbertb/papers/memerrors_raid12.pdf},
	booktitle = {{RAID}},
	author = {van der Veen, Victor and Dutt-Sharma, Nitish and Cavallaro, Lorenzo and Bos, Herbert},
	month = oct,
	year = {2012},
	keywords = {type\_conf, type\_top},
}

@article{10.1145/1103845.1094836,
author = {Hertz, Matthew and Berger, Emery D.},
title = {Quantifying the Performance of Garbage Collection vs. Explicit Memory Management},
year = {2005},
issue_date = {October 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1103845.1094836},
doi = {10.1145/1103845.1094836},
abstract = {Garbage collection yields numerous software engineering benefits, but its quantitative impact on performance remains elusive. One can compare the cost of conservative garbage collection to explicit memory management in C/C++ programs by linking in an appropriate collector. This kind of direct comparison is not possible for languages designed for garbage collection (e.g., Java), because programs in these languages naturally do not contain calls to free. Thus, the actual gap between the time and space performance of explicit memory management and precise, copying garbage collection remains unknown.We introduce a novel experimental methodology that lets us quantify the performance of precise garbage collection versus explicit memory management. Our system allows us to treat unaltered Java programs as if they used explicit memory management by relying on oracles to insert calls to free. These oracles are generated from profile information gathered in earlier application runs. By executing inside an architecturally-detailed simulator, this "oracular" memory manager eliminates the effects of consulting an oracle while measuring the costs of calling malloc and free. We evaluate two different oracles: a liveness-based oracle that aggressively frees objects immediately after their last use, and a reachability-based oracle that conservatively frees objects just after they are last reachable. These oracles span the range of possible placement of explicit deallocation calls.We compare explicit memory management to both copying and non-copying garbage collectors across a range of benchmarks using the oracular memory manager, and present real (non-simulated) runs that lend further validity to our results. These results quantify the time-space tradeoff of garbage collection: with five times as much memory, an Appel-style generational collector with a non-copying mature space matches the performance of reachability-based explicit memory management. With only three times as much memory, the collector runs on average 17% slower than explicit memory management. However, with only twice as much memory, garbage collection degrades performance by nearly 70%. When physical memory is scarce, paging causes garbage collection to run an order of magnitude slower than explicit memory management.},
journal = {SIGPLAN Not.},
month = oct,
pages = {313–326},
numpages = {14},
keywords = {throughput, explicit memory management, oracular memory management, performance analysis, time-space tradeoff, garbage collection, paging}
}

@inproceedings{10.1145/1094811.1094836,
author = {Hertz, Matthew and Berger, Emery D.},
title = {Quantifying the Performance of Garbage Collection vs. Explicit Memory Management},
year = {2005},
isbn = {1595930310},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1094811.1094836},
doi = {10.1145/1094811.1094836},
abstract = {Garbage collection yields numerous software engineering benefits, but its quantitative impact on performance remains elusive. One can compare the cost of conservative garbage collection to explicit memory management in C/C++ programs by linking in an appropriate collector. This kind of direct comparison is not possible for languages designed for garbage collection (e.g., Java), because programs in these languages naturally do not contain calls to free. Thus, the actual gap between the time and space performance of explicit memory management and precise, copying garbage collection remains unknown.We introduce a novel experimental methodology that lets us quantify the performance of precise garbage collection versus explicit memory management. Our system allows us to treat unaltered Java programs as if they used explicit memory management by relying on oracles to insert calls to free. These oracles are generated from profile information gathered in earlier application runs. By executing inside an architecturally-detailed simulator, this "oracular" memory manager eliminates the effects of consulting an oracle while measuring the costs of calling malloc and free. We evaluate two different oracles: a liveness-based oracle that aggressively frees objects immediately after their last use, and a reachability-based oracle that conservatively frees objects just after they are last reachable. These oracles span the range of possible placement of explicit deallocation calls.We compare explicit memory management to both copying and non-copying garbage collectors across a range of benchmarks using the oracular memory manager, and present real (non-simulated) runs that lend further validity to our results. These results quantify the time-space tradeoff of garbage collection: with five times as much memory, an Appel-style generational collector with a non-copying mature space matches the performance of reachability-based explicit memory management. With only three times as much memory, the collector runs on average 17% slower than explicit memory management. However, with only twice as much memory, garbage collection degrades performance by nearly 70%. When physical memory is scarce, paging causes garbage collection to run an order of magnitude slower than explicit memory management.},
booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
pages = {313–326},
numpages = {14},
keywords = {explicit memory management, oracular memory management, time-space tradeoff, throughput, performance analysis, garbage collection, paging},
location = {San Diego, CA, USA},
series = {OOPSLA '05}
}

@inproceedings{10.1145/780732.780743,
author = {Dhurjati, Dinakar and Kowshik, Sumant and Adve, Vikram and Lattner, Chris},
title = {Memory Safety without Runtime Checks or Garbage Collection},
year = {2003},
isbn = {1581136471},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/780732.780743},
doi = {10.1145/780732.780743},
abstract = {Traditional approaches to enforcing memory safety of programs rely heavily on runtime checks of memory accesses and on garbage collection, both of which are unattractive for embedded applications. The long-term goal of our work is to enable 100% static enforcement of memory safety for embedded programs through advanced compiler techniques and minimal semantic restrictions on programs. The key result of this paper is a compiler technique that ensures memory safety of dynamically allocated memory without programmer annotations, runtime checks, or garbage collection, and works for a large subclass of type-safe C programs. The technique is based on a fully automatic pool allocation (i.e., region-inference) algorithm for C programs we developed previously, and it ensures safety of dynamically allocated memory while retaining explicit deallocation of individual objects within regions (to avoid garbage collection). For a diverse set of embedded C programs (and using a previous technique to avoid null pointer checks), we show that we are able to statically ensure the safety of pointer and dynamic memory usage in all these programs. We also describe some improvements over our previous work in static checking of array accesses. Overall, we achieve 100% static enforcement of memory safety without new language syntax for a significant subclass of embedded C programs, and the subclass is much broader if array bounds checks are ignored. Overall, these techniques greatly expand the class of embedded programs for which 100% static enforcement of memory safety is possible, and furthermore can be achieved without new language support.},
booktitle = {Proceedings of the 2003 ACM SIGPLAN Conference on Language, Compiler, and Tool for Embedded Systems},
pages = {69–80},
numpages = {12},
keywords = {compilers, automatic pool allocation, programming languages, security, embedded systems, region management, static analysis},
location = {San Diego, California, USA},
series = {LCTES '03}
}

@article{10.1145/780731.780743,
author = {Dhurjati, Dinakar and Kowshik, Sumant and Adve, Vikram and Lattner, Chris},
title = {Memory Safety without Runtime Checks or Garbage Collection},
year = {2003},
issue_date = {July 2003},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {38},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/780731.780743},
doi = {10.1145/780731.780743},
abstract = {Traditional approaches to enforcing memory safety of programs rely heavily on runtime checks of memory accesses and on garbage collection, both of which are unattractive for embedded applications. The long-term goal of our work is to enable 100% static enforcement of memory safety for embedded programs through advanced compiler techniques and minimal semantic restrictions on programs. The key result of this paper is a compiler technique that ensures memory safety of dynamically allocated memory without programmer annotations, runtime checks, or garbage collection, and works for a large subclass of type-safe C programs. The technique is based on a fully automatic pool allocation (i.e., region-inference) algorithm for C programs we developed previously, and it ensures safety of dynamically allocated memory while retaining explicit deallocation of individual objects within regions (to avoid garbage collection). For a diverse set of embedded C programs (and using a previous technique to avoid null pointer checks), we show that we are able to statically ensure the safety of pointer and dynamic memory usage in all these programs. We also describe some improvements over our previous work in static checking of array accesses. Overall, we achieve 100% static enforcement of memory safety without new language syntax for a significant subclass of embedded C programs, and the subclass is much broader if array bounds checks are ignored. Overall, these techniques greatly expand the class of embedded programs for which 100% static enforcement of memory safety is possible, and furthermore can be achieved without new language support.},
journal = {SIGPLAN Not.},
month = jun,
pages = {69–80},
numpages = {12},
keywords = {region management, security, programming languages, automatic pool allocation, static analysis, embedded systems, compilers}
}

@ARTICLE{8688434,  author={Neshenko, Nataliia and Bou-Harb, Elias and Crichigno, Jorge and Kaddoum, Georges and Ghani, Nasir},  journal={IEEE Communications Surveys   Tutorials},   title={Demystifying IoT Security: An Exhaustive Survey on IoT Vulnerabilities and a First Empirical Look on Internet-Scale IoT Exploitations},   year={2019},  volume={21},  number={3},  pages={2702-2733},  doi={10.1109/COMST.2019.2910750}}

@inproceedings{10.1145/2663171.2663188,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The Rust Language},
year = {2014},
isbn = {9781450332170},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2663171.2663188},
doi = {10.1145/2663171.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
booktitle = {Proceedings of the 2014 ACM SIGAda Annual Conference on High Integrity Language Technology},
pages = {103–104},
numpages = {2},
keywords = {systems programming, memory management, affine type systems, rust},
location = {Portland, Oregon, USA},
series = {HILT '14}
}

@article{10.1145/2692956.2663188,
author = {Matsakis, Nicholas D. and Klock, Felix S.},
title = {The Rust Language},
year = {2014},
issue_date = {December 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {3},
issn = {1094-3641},
url = {https://doi.org/10.1145/2692956.2663188},
doi = {10.1145/2692956.2663188},
abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety.Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
journal = {Ada Lett.},
month = oct,
pages = {103–104},
numpages = {2},
keywords = {affine type systems, memory management, systems programming, rust}
}

@INPROCEEDINGS{8049734,  author={Patrignani, Marco and Garg, Deepak},  booktitle={2017 IEEE 30th Computer Security Foundations Symposium (CSF)},   title={Secure Compilation and Hyperproperty Preservation},   year={2017},  volume={},  number={},  pages={392-404},  doi={10.1109/CSF.2017.13}}

@ARTICLE{2019arXiv190300982W,
       author = {{Weiss}, Aaron and {Gierczak}, Olek and {Patterson}, Daniel and {Matsakis}, Nicholas D. and {Ahmed}, Amal},
        title = "{Oxide: The Essence of Rust}",
      journal = {arXiv e-prints},
     keywords = {Computer Science - Programming Languages},
         year = 2019,
        month = mar,
          eid = {arXiv:1903.00982},
        pages = {arXiv:1903.00982},
archivePrefix = {arXiv},
       eprint = {1903.00982},
 primaryClass = {cs.PL},
       adsurl = {https://ui.adsabs.harvard.edu/abs/2019arXiv190300982W},
      adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

@article{10.1145/3158154,
author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
title = {RustBelt: Securing the Foundations of the Rust Programming Language},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158154},
doi = {10.1145/3158154},
abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
journal = {Proc. ACM Program. Lang.},
month = dec,
articleno = {66},
numpages = {34},
keywords = {Rust, logical relations, type systems, concurrency, separation logic}
}

@misc{rustbook,
  title = {Validating References with Lifetimes},
  howpublished = {\url{https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html}},
  note = {Accessed: 2021-06-01}
}

@misc{cherillvm,
  title = {LLVM with CHERI Support},
  howpublished = {\url{https://github.com/CTSRD-CHERI/llvm-project}},
  note = {Accessed: 2021-06-01}
}

@misc{morello,
  title = {ARM Morello Program},
  howpublished = {\url{https://www.morello-project.org/}},
  note = {Accessed: 2021-06-01}
}

@techreport{Waterman:EECS-2011-62,
    Author = {Waterman, Andrew and Lee, Yunsup and Patterson, David A. and Asanović, Krste},
    Title = {The RISC-V Instruction Set Manual, Volume I: Base User-Level ISA},
    Institution = {EECS Department, University of California, Berkeley},
    Year = {2011},
    Month = {May},
    URL = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2011/EECS-2011-62.html},
    Number = {UCB/EECS-2011-62}
}

@article{10.1145/3290384,
author = {Armstrong, Alasdair and Bauereiss, Thomas and Campbell, Brian and Reid, Alastair and Gray, Kathryn E. and Norton, Robert M. and Mundkur, Prashanth and Wassell, Mark and French, Jon and Pulte, Christopher and Flur, Shaked and Stark, Ian and Krishnaswami, Neel and Sewell, Peter},
title = {ISA Semantics for ARMv8-a, RISC-v, and CHERI-MIPS},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290384},
doi = {10.1145/3290384},
abstract = { Architecture specifications notionally define the fundamental interface between hardware and software: the envelope of allowed behaviour for processor implementations, and the basic assumptions for software development and verification. But in practice, they are typically prose and pseudocode documents, not rigorous or executable artifacts, leaving software and verification on shaky ground.  In this paper, we present rigorous semantic models for the sequential behaviour of large parts of the mainstream ARMv8-A, RISC-V, and MIPS architectures, and the research CHERI-MIPS architecture, that are complete enough to boot operating systems, variously Linux, FreeBSD, or seL4. Our ARMv8-A models are automatically translated from authoritative ARM-internal definitions, and (in one variant) tested against the ARM Architecture Validation Suite.  We do this using a custom language for ISA semantics, Sail, with a lightweight dependent type system, that supports automatic generation of emulator code in C and OCaml, and automatic generation of proof-assistant definitions for Isabelle, HOL4, and (currently only for MIPS) Coq. We use the former for validation, and to assess specification coverage. To demonstrate the usability of the latter, we prove (in Isabelle) correctness of a purely functional characterisation of ARMv8-A address translation. We moreover integrate the RISC-V model into the RMEM tool for (user-mode) relaxed-memory concurrency exploration. We prove (on paper) the soundness of the core Sail type system.  We thereby take a big step towards making the architectural abstraction actually well-defined, establishing foundations for verification and reasoning. },
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {71},
numpages = {31},
keywords = {Instruction Set Architectures, Theorem Proving, Semantics}
}

@ARTICLE{7723791,  author={Watson, Robert N.M. and Norton, Robert M. and Woodruff, Jonathan and Moore, Simon W. and Neumann, Peter G. and Anderson, Jonathan and Chisnall, David and Davis, Brooks and Laurie, Ben and Roe, Michael and Dave, Nirav H. and Gudka, Khilan and Joannou, Alexandre and Markettos, A. Theodore and Maste, Ed and Murdoch, Steven J. and Rothwell, Colin and Son, Stacey D. and Vadera, Munraj},  journal={IEEE Micro},   title={Fast Protection-Domain Crossing in the CHERI Capability-System Architecture},   year={2016},  volume={36},  number={5},  pages={38-49},  doi={10.1109/MM.2016.84}}


@mastersthesis{uninitcap,
  author       = {Sander Huyghebaert}, 
  title        = {Secure Calling Convention with Uninitialized Capabilities},
  school       = {Vrije Universiteit Brussel},
  year         = 2020
}

@misc{riscvtest,
  title = {RISC-V test assembly code},
  howpublished = {\url{https://github.com/riscv/riscv-test-env/blob/43d3d53809085e2c8f030d72eed1bdf798bfb31a/p/riscv_test.h}},
  note = {Accessed: 2021-06-01}
}
