\chapter{Mapping Borrowed Capabilities to Architecture}
In this chapter we will discuss the concrete implementation of the design outlined in section \ref{sec:maindesign}. First, we will discuss the specifics of linear capabilities which are based on previous work. We lean heavily on the suggestions outlined in the CHERI specification\cite{UCAM-CL-TR-951} for the implementation of linear capabilities. Then we describe the implementation of borrowed capabilities which are built on top of linear capabilities. Throughout this chapter we keep possible microarchitectural limitations in mind, but we do not discuss them in depth.

\section{Linear Capabilities}
Figure \ref{fig:linear_capability} shows the layout of a 128-bit CHERI-RISC-V capability with linearity support. The only differences between this format and the format shown in \ref{fig:cheri_capability} is the addition of a \textit{flag} field, required in the CHERI-RISC-V architecture as described in section \ref{sec:cheri-risc-v} and the addition of a \textit{linear} field. The linear field consists of only one bit which indicates whether the capability is linear or not.

\begin{figure}[h]
\centering
\definecolor{lightgray}{gray}{0.8}
\begin{bytefield}[endianness=big, bitwidth=.55em]{64}
    \bitheader{0,63} \\
    \bitbox{13}{\textit{p}'16} & \bitbox{2}{\color{lightgray}\rule{\width}{\height}} & \bitbox{2}{\textit{l}} & \bitbox{2}{\textit{f}} & \bitbox{15}{otype'18} & \bitbox{3}{\textit{$I_E$}} & \bitbox{8}{\textit{T}[11:3]} & \bitbox{5}{\textit{$T_E$}'3} & \bitbox{9}{\textit{B}[13:3]} & \bitbox{5}{\textit{$B_E$}'3} \\
    \bitbox{64}{\textit{a}'64}
\end{bytefield}
\caption{CHERI-RISC-V capability with a linearity bit.}
\label{fig:linear_capability}
\end{figure}

When the \textit{linear} bit on a capability is set, it cannot be copied in any way. This restriction has influence on a large amount of instructions in the ISA. We describe the necessary modifications to existing instructions as well as the new instructions that were made in the sections below.

\subsection{Instructions with Modification Semantics}
The first set of instructions are a class of instructions that modify existing capabilities. These instructions are allowed to have a destination register that is different from their capability source register. This is analogous to most normal RISC-V instructions where the destination register can also be different from the source. This design makes sense in most cases, but it poses difficulties for linear capabilities. The most obvious linearity violation is an update to a capability that does not even modify the capability. A simple example of this would be the removal of a permission that was not present on the source capability. This results in the capability being copied unmodified from the source to the destination register which is an obvious violation of linearity.

However, even modifications to a capability usually constitute a linearity violation. When using capabilities as pointers to a section of memory, linearity is usually used as a means of proving exclusive access to that section of memory. Any instruction that produces a modified capability that points to the same memory section as the source capability or a subset of it can potentially violate linearity.

To prevent these violations of linearity, we have chosen to modify the existing CHERI instructions with modification semantics to raise a hardware exception when they try to output the modified capability to a different register than the register of the source capability if the source capability is linear. This prevents capabilities from being copied as the source capability will always be overwritten by the modified capability.It is the responsibility of the compiler to make sure that the destination register equals the source register when trying to modify a linear capability.

This is a fairly unintrusive change since it only modifies the instructions' behavior when the linearity bit is set which means it is backwards compatible with existing CHERI software. This change should also be fairly straightforward to implement in microarchitecture. This approach does have a minor impact on performance as an extra move instruction for linear capabilities might be necessary in some cases. Another concern is the effect on compiler code generation since due to this change, more instructions may trap for more reasons than before. This might make it harder for the compiler to generate efficient code.

To go along with the changes to the instructions, an extra exception type named \textit{CapEx\_LinearityViolation} was added to the list of hardware exceptions.

Table \ref{table:linearitymodification} contains the existing CHERI instructions with modification semantics that had to be modified.

\begin{table}[h]
\centering
\begin{tabular}{| c |}
\hline
 CAndPerm \\
 CSetFlags \\
 CIncOffset \\
 CIncOffsetImmediate \\
 CSetOffset \\
 CSetAddr \\
 CSetBounds \\
 CSetBoundsImmediate \\
 CSetBoundsExact \\
 CFromPtr \\
 CBuildCap \\
 CCopyType \\
 CSeal \\
 CCSeal \\
 CUnseal \\
 CSealEntry \\
\hline
\end{tabular}
\caption{Modification Instructions}
\label{table:linearitymodification}
\end{table}

\subsection{Instructions with Move Semantics}
A second set of instructions consists of instructions that are meant to move capabilities between (special) registers. Using the approach from the previous section where the destination register must equal the source register is not an option here as this would defeat the purpose of these instructions.

The most simple of these instructions is the \textit{CMove} instruction which simply moves a capability from the source register to the destination register. This move is essentially a copy since the instruction does not clear the source register. To prevent this violation of linearity we have opted to clear the tag of the source register if the capability that is being moved is linear. This invalidates the capability in the source register. While clearing the source register seems like a straightforward and simple operation, this requires writing to multiple registers in one instruction and might pose a microarchitectural challenge. The other instructions described in this section use the same solution.

The \textit{CJALR} instruction copies the capability in the PCC special register to the destination register and replaces it with the capability in the source register. If the source capability is linear, the tag on the source register will be cleared.

The \textit{CInvoke} instruction described in section \ref{sec:sealed} places the capability in the first source register in the PCC and moves the capability in the second source register to \textit{C31}. Both source registers for this instruction have the opportunity to violate linearity. For the first source capability, this is solved like the other instructions in this section: if it is linear, the tag of the first source register will be cleared. For the second source capability the linearity violation is prevented by raising a hardware exception if the second source capability is linear and the second source register is not equal to \textit{C31}. This is analogous to the instructions in the previous section.

The \textit{CSpecialRW} instruction copies the capability in the specified special register to the destination register and replaces it with the capability in the source register. If the capability in the source register is equal to \textit{C0}, the special register is not replaced. To make this instruction comply with the linearity bit, it was changed to clear the tag of the special register if the capability in it is linear and if the source register is equal to \textit{C0}. However, if the source register is not equal to \textit{C0}, this becomes unnecessary as the special register is overwritten anyways. In this case there is a linearity violation when the source register has its \textit{linear} bit set. Thus the instruction was changed to raise a hardware exception if the capability in the source register is linear and the destination register does not equal the source register.

The \textit{AUIPCC} instruction copies the capability in the PCC to a regular register. For this instruction we chose to clear the tag on the destination register if the capability in the PCC has it \textit{linear} bit set and to not modify the capability in the PCC. This is consistent with CHERI's design of not letting software manipulate the PCC directly.

\subsection{Load \& Store Instructions}
A third set of instructions that need to be modified are load and store instructions, specifically those dedicated to loading and storing capabilities. We follow the suggestion in the CHERI specification and introduce new load and store instructions to load and store linear capabilities as well as modify existing load and store instructions to respect linearity. Table \ref{table:loadstoreinst} contains the modified and added instructions.

\begin{table}[h]
\centering
\begin{tabular}{| c | c | c | c |}
\hline
 Existing Load & Existing Store & New Load & New Store \\
 \hline
 LoadCapDDC & StoreCapDDC & & \\
 LoadCapImm & StoreCapImm & & \\
 LoadCapCap & StoreCapCap & LinearLoadCapCap & LinearStoreCapCap \\
\hline
\end{tabular}
\caption{Load \& Store Instructions}
\label{table:loadstoreinst}
\end{table}

Load instructions were modified to clear the tag of the destination register if the loaded capability has its \textit{linear} bit set. This means that linear capabilities cannot be loaded from memory through these instructions as they will always become invalid. This approach was taken to avoid having to write to memory depending on the capability that was loaded, simplifying the microarchitectural implementation.

Store instructions were modified to clear the tag of the source register if the stored capability has its \textit{linear} bit set. This means that it is possible to successfully store linear capabilities through regular store instructions, in contrast to load instructions. The reason for this design is that clearing the tag on a register conditioned on the capability in that register is much cheaper than clearing a tag in memory conditioned on a loaded capability as is the case with load instructions.

Because linear capabilities cannot be successfully loaded from memory through regular load instructions, a new linear load instruction is necessary. This is the newly introduced \textit{LinearLoadCapCap} which loads a capability from memory to the destination register based on the \textit{address} field of the capability in the source register. Loading a capability in this manner will always clear the tag in memory of the loaded capability, regardless of whether it has its \textit{linear} bit set. This unconditional write avoids the issue with conditional writes that was encountered with the regular load instructions. As seen in table \ref{table:loadstoreinst}, we chose to only introduce an instruction that loads capabilities based on the \textit{address} field of a capability as opposed to including instructions that load capabilities based on the DCC or an immediate. This decision was made to save on instruction encoding space, but might cause a performance impact.

The new \textit{LinearStoreCapCap} instruction is the store equivalent of the \textit{LinearLoadCapCap} instruction. It stores the capability in the first source register in memory based on the \textit{address} field of the capability in the second source register and unconditionally clears the tag of the first source register. This instruction is not strictly necessary as linear capabilities can be successfully stored by regular store instructions, but the presence of this instructions adds symmetry between linear load and store instructions.

\subsection{Linearity Instructions}
Finally, two new instructions were added to inspect and manipulate a capability's \textit{linear} bit and two new instructions were added to split and merge linear capabilities. These split and merge instructions will also be useful for borrowed capabilies as shown in section \ref{sec:borrowmodinsts}. The added instructions are shown in table \ref{table:linearityinst}.

The \textit{CGetLinear} instruction sets the least significant bit of the integer in the destination register to the same value as the \textit{linear} bit of the capability in the source register and clears all the other bits of the integer. This behavior is analogous to the already existing capability field inspection instructions such as \textit{CGetPerm}.

The \textit{CMakeLinear} instruction copies the capability in the source register to the destination register and sets its \textit{linear} bit. This irreversibly\footnote{As part of the design of borrowed capabilities we will provide a controlled way to break linearity for some capabilities.} makes a capability linear to ensure that it cannot be copied. Of course a capability can be copied before it is made linear. This allows software to delegate a linear capability to an untrusted component to restrict its use of the capability while retaining an unrestricted copy of the capability itself. There may be applications of linear capabilities that require unsetting or overriding the \textit{linear} bit on a capability, but for the purposes of this thesis, the irreversible \textit{CMakeLinear} operation is sufficient.

The \textit{CSplitCap} instruction splits the capability in the first source register in two with the boundaries of both parts determined by the integer offset specified in the second source register. After the execution of this instruction, the top of the capability in the first source register is changed to its base plus the specified offset and the destination register holds a copy of the capability in the first source register with its base set to the original base plus the specified offset plus one. This instruction is intended to split linear capabilities but can also be used on other capabilities. Because this instruction writes to multiple registers, it might be hard to implement in microarchitecture.

The \textit{CMergeCap} instruction reverts the split from \textit{CSplitCap}. It requires two capabilities pointing to contiguous memory sections in its source registers and joins them together to form a single capability that points to the entire memory section. This instruction clears the tags on its source registers. Like \textit{CSplitCap}, this instruction is intended to be used with linear capabilities, but can also be used on other capabilities.

\begin{table}[h]
\centering
\begin{tabular}{| c |}
\hline
 CGetLinear \\
 CMakeLinear \\
 CSplitCap \\
 CMergeCap \\
\hline
\end{tabular}
\caption{Linearity Instructions}
\label{table:linearityinst}
\end{table}

\section{Borrowed Capabilities}
In this section we discuss the implementation of the design of borrowed capabilities. We start off with a look at the memory representation of the newly introduced tokens. Next, we describe the newly required architectural elements and finally we expand on the changes needed to existing instructions as well as the definitions of new instructions.
\subsection{Token Layouts}
In this section we introduce the memory layout of the lifetime and index tokens and discuss the design decisions pertaining to these tokens. It was decided to fit all of the necessary new fields into fields that also exist in the regular CHERI capability layout to simplify the interpretation of fields. This means that all of the new fields are either renamed from an existing field or fit into a larger existing field. We do not combine bits of two separate existing fields into one new field.

\subsubsection{Lifetime Tokens}
Figure \ref{fig:lifetime_token} shows the layout of a lifetime token.

\begin{figure}[h]
\centering
\definecolor{lightgray}{gray}{0.8}
\begin{bytefield}[endianness=big, bitwidth=.55em]{64}
    \bitheader{0,63} \\
    \bitbox{13}{\textit{p}'16} & \bitbox{2}{\color{lightgray}\rule{\width}{\height}} & \bitbox{2}{\textit{l}} & \bitbox{2}{\textit{f}} & \bitbox{15}{otype'18} & \bitbox{3}{\textit{$I_E$}} & \bitbox{13}{\textit{T}'11} & \bitbox{14}{fraction'13} \\
    \bitbox{10}{\color{lightgray}\rule{\width}{\height}} & \bitbox{18}{parent id'18} & \bitbox{18}{child id'18} & \bitbox{18}{lifetime id'18}
\end{bytefield}
\caption{The layout of a lifetime token.}
\label{fig:lifetime_token}
\end{figure}

The \textit{permissions} field is unaltered from the regular capability layout, but since none of the permissions are relevant for lifetime tokens, all permissions are set to zero.

The \textit{linear} field serves the same purpose as it does in linear capabilities, but it also indicates whether a lifetime token is alive or dead. Alive lifetime tokens always have their \textit{linear} bit set, while dead lifetime tokens never do.

The \textit{flags} field is unaltered from the regular capability layout.

The \textit{otype} field is always set to the identifier for lifetime tokens: $2^{18} - 3$. This allows both the software and the hardware to confirm whether a capability is a lifetime token by checking its \textit{otype} field.

The $I_E$ bit is always set to 0. This allows us the use the full width of the \textit{B} field which is repurposed to the \textit{fraction} field. The \textit{fraction} field holds the fraction of the lifetime token. A full lifetime token has a fraction of zero. When a full lifetime token is split, two lifetime tokens with fraction 1 are produced. Those lifetime tokens can then be split again, producing lifetime tokens with fraction 2. Lifetime tokens can continue to be split until the maximum value of of the \textit{fraction} field is reached. Since the \textit{fraction} field is 13 bits wide, the theoretical maximum amount of lifetime tokens is $2^{13}=8192$. Two lifetime tokens can be merged if their fractions are equal and not zero. The merging of two identical lifetime tokens results in a lifetime token with its \textit{fraction} field decremented.

The \textit{T} field is not used in lifetime tokens and is set to zero.

The previous \textit{a} field is split up into three different fields to hold a lifetime token's own lifetime id, the id of its parent and the id of its child. Because each of these fields is 18 bits wide, the bottom word of a capability contains 10 unassigned bits. While the necessity of a lifetime token holding its own id is clear, the need for fields to store the parent and child id's might be less obvious. Reborrowing a capability under a new lifetime requires the parent id of the new lifetime to be the lifetime id that the capability was originally borrowed under. This can only be checked if a lifetime token holds the id of its parent. The necessity of the \textit{child id} field arises from the restriction that lifetime tokens cannot be killed while they have a child. This means that there needs to be a way to determine whether a lifetime token has a child as well as a way to modify the lifetime token when its child lifetime is dead. It might seem possible to use a single bit to indicate whether a specified lifetime token has a child and clear that bit through an operation that uses a dead lifetime token with the \textit{parent id} field set to the lifetime id of the specified lifetime token. However, since lifetime tokens can have multiple children in succession, using one bit to track whether a lifetime token has a child is unsufficient as this would allow old children to be used to remove the bit. Storing the entire lifetime id of the child lifetime in the \textit{child id} field solves this problem.

\subsubsection{Index Tokens}
Figure \ref{fig:index_token} shows the layout of an index token.

\begin{figure}[h]
\centering
\definecolor{lightgray}{gray}{0.8}
\begin{bytefield}[endianness=big, bitwidth=.55em]{64}
    \bitheader{0,63} \\
    \bitbox{13}{\textit{p}'16} & \bitbox{2}{\color{lightgray}\rule{\width}{\height}} & \bitbox{2}{\textit{l}} & \bitbox{2}{\textit{f}} & \bitbox{15}{otype'18} & \bitbox{3}{\textit{$I_E$}} & \bitbox{8}{\textit{T}[11:3]} & \bitbox{5}{\textit{$T_E$}'3} & \bitbox{9}{\textit{B}[13:3]} & \bitbox{5}{\textit{$B_E$}'3} \\
    \bitbox{30}{\color{lightgray}\rule{\width}{\height}} & \bitbox{18}{lifetime id'18} & \bitbox{16}{index'16}
\end{bytefield}
\caption{The layout of an index token.}
\label{fig:index_token}
\end{figure}

Like with lifetime tokens, the \textit{permissions} field is unmodified, but because there is no use for the permissions, every permission is set to zero.

The \textit{linear} bit is unaltered from the regular capability layout. Because index tokens should only be used to retrieve a stored capability once, they are always linear and are consumed in the retrieval operation.

The \textit{flags} field is unaltered from the regular capability layout.

The \textit{otype} field is always set to the identifier for index tokens: $2^{18} - 4$. This allows both the software and hardware to confirm whether a capability is an index token by checking its \textit{otype} field.

Index tokens do not use the fields related to bounds which means the $I_E$, \textit{T} and \textit{B} fields are unaltered from the regular capability layout and set to zero.

The previous \textit{a} field is split up into two different fields to hold the index in the borrow table and the lifetime id associated with the token. These two fields are 18 and 16 bits wide which means that the second word of an index token has 30 unassigned bits. The \textit{lifetime id} field indicates which lifetime id this index token corresponds to. A capability can only be retrieved when a dead lifetime token with the lifetime id in this field is present. The \textit{index} field indicates which capability should be retrieved when consuming the index token. The width of this field proportional to the size of the borrow table which is discussed in section \ref{sec:lcbt}.

\subsubsection{Memory Capabilities}
The layout of memory capabilities does not get changed with the introduction of borrowed capabilities. It remains the same layout that was introduced by linear capabilities in figure \ref{fig:linear_capability}. However, the introduction of borrowed capabilities does make a breaking change with regards to the \textit{otype} field.

Whereas previously almost the full otype range was reserved for code-data pairs, the introduction of borrowed capabilities splits this otype space in two, reserving half of it for use as lifetime id's. This results in three separate otype ranges. The first range, from 0 to $\frac{2^{18}}{2} - 1$ is used for lifetime id's. The first value of zero is not actually used as a valid lifetime id, but exists to represent the absence of a child or parent lifetime in lifetime tokens. The second range, from  $\frac{2^{18}}{2}$ to $2^{18} - 17$ is used for code-data pairs. The last range, from $2^{18} - 16$ to $2^{18} - 1$ is reserved for specific identifiers such as the lifetime token identifier and the index token identifier as discussed above. Note that borrowed memory capabilities can be identified by the presence of a lifetime id in their \textit{otype} field. Thanks to splitting the otype space in half, this can be accomplished by checking just the first bit of the otype field.

An alternative to this scheme would be to add an extra bit that determines whether the value held in the \textit{otype} field represents a lifetime id or a code-data pair. While this approach would keep compatibility with the existing CHERI architecture, it would also use the last of the leftover bits and complicate the interpretation of the \textit{otype} field as the interpretation would depend on a separate bit.

\subsection{Lifetime Counter \& Borrow Table}
\label{sec:lcbt}
Borrowed capabilities require a method to securely generate new lifetime id's. It should at all times be impossible to reuse an existing lifetime id as this would enable vulnerabilities such as using an old dead lifetime token to prove the death of a currently living lifetime. To generate new unique lifetimes we introduce an internal hardware register called the lifetime counter. This lifetime counter is initialized to one and incremented every time a new lifetime id gets created. The size of this lifetime counter corresponds to the size of the \textit{otype} field which is 18 bits. When the software tries to create a lifetime id that is out of the allowed range, a hardware exception is raised. This is further described in section \ref{sec:lifetimeinsts}.

Borrowed capabilities also require a table to store and retrieve capabilities that are being borrowed. From the perspective of the software, this is an opaque table that stores capabilities when they get borrowed and retrieves them when the software asks to. The only aspect of this table that is exposed to the software is the index of where a capability is stored. In microarchitecture, the table is most likely stored in system memory. The management of the table could be implemented by a privileged entity such as the kernel. In this scheme, instructions that need to access the table would trap to the operating system which would then store or retrieve table entries from system memory. Such a mechanism used to be present in older CHERI versions in the CCall instruction. %TODO reference this

The borrow table has the ability to
\begin{itemize}
\item Find free slots in the table.
\item Store a capability in a free slot and return the index of the slot in which it was stored.
\item Retrieve a capability in the slot with a specific index and clear the slot.
\end{itemize}

The size of the table was chosen to be $2^{16}$ entries, but is only really limited by the amount of space in index tokens. The layout of the index token that was discussed in the previous section contains 30 unassigned bits so the width of the \textit{index} field could theoretically grow to 46 bits, allowing for a table with a size of $2^{46}$ entries. However for performance and simplicity reasons, it seems desirable for the borrow table to be small. Thus a size of $2^{16}$ bits was chosen.

\subsection{Modified Instructions}

\label{sec:borrowmodinsts}
%TODO load and store instructions modified to need lifetime token, CSplitCap and CMergeCap, cseal to not allow lifetime ids, instructions that change offsets

\subsection{New Instructions}
\subsubsection{Lifetime Instructions}
\label{sec:lifetimeinsts}
\subsubsection{Borrow Instructions}
\subsubsection{Other Instructions}
